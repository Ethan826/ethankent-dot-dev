<!DOCTYPE html>
<html lang="en-us">
    <head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<title>Breaking out of the fold &middot; Ethan Kent&#39;s Blog</title>

		
  		<link rel="stylesheet" href="/css/style.css">
		<link rel="stylesheet" href="/css/fonts.css">
		
		<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
		<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

		
		<link href="" rel="alternate" type="application/rss+xml" title="Ethan Kent&#39;s Blog" />
	</head>

    <body>
        		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					<h2 class="nav-title">Ethan Kent&#39;s Blog</h2>
				</a>
				<ul>
    
    
</ul>
			</div>
		</nav>

        

<main>
	<div class="post">
		<div class="post-info">
    <span>Written by</span>
        Ethan Kent
        <br>
        <span>on&nbsp;</span><time datetime="2019-12-15 15:58:10 -0600 CST">December 15, 2019</time>
</div>
		<h1 class="post-title">Breaking out of the fold</h1>
<div class="post-line"></div>

		

		<p>This article addresses an issue <a href="https://ethankent.dev/posts/i_fold#fold-can-be-used-to-define-all-the-other-important-higher-order-functions">alluded
to</a>
in my previous one. Namely, we sometimes want to break out of the iteration
within <code>fold</code>, but it is not easy to do that in many languages.</p>
<h2 id="fold-has-a-problem-with-short-circuiting"><code>fold</code> has a problem with short-circuiting.</h2>
<p>In defining <code>any</code> and <code>all</code> by using <code>fold</code>, as we did in the <a href="https://ethankent.dev/posts/i_fold#fold-can-be-used-to-define-all-the-other-important-higher-order-functions">previous
article</a>,
we did not short-circuit. But we'd get a better constant factor for our time
complexity if we can <code>break</code> from those methods once we know the final
outcome.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> Let's see if we can do this with Ruby (using
the built-in <code>reduce</code> method):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="color:#75715e"># `any` using `reduce`; we&#39;re going to skip the actual function definition as I</span>
<span style="color:#75715e"># don&#39;t want to distract with Ruby&#39;s weird blocks and lambdas.</span>
<span style="color:#f92672">!</span><span style="color:#f92672">!</span><span style="color:#f92672">[</span><span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span><span style="color:#f92672">]</span><span style="color:#f92672">.</span>reduce(<span style="color:#66d9ef">false</span>) <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>a, e<span style="color:#f92672">|</span>
  puts e ? <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Breaking</span><span style="color:#e6db74">&#34;</span> : <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Continuing</span><span style="color:#e6db74">&#34;</span>
  <span style="color:#66d9ef">break</span> <span style="color:#66d9ef">true</span> <span style="color:#66d9ef">if</span> e
  a <span style="color:#75715e"># We&#39;d actually use `each_with_object`, but that&#39;s not the point here.</span>
<span style="color:#66d9ef">end</span>

<span style="color:#75715e"># Continuing</span>
<span style="color:#75715e"># Continuing</span>
<span style="color:#75715e"># Continuing</span>
<span style="color:#75715e"># Continuing</span>
<span style="color:#75715e"># Continuing</span>
<span style="color:#75715e"># =&gt; false</span>

<span style="color:#f92672">!</span><span style="color:#f92672">!</span><span style="color:#f92672">[</span><span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span><span style="color:#f92672">]</span><span style="color:#f92672">.</span>reduce(<span style="color:#66d9ef">false</span>) <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>a, e<span style="color:#f92672">|</span>
  puts e ? <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Breaking</span><span style="color:#e6db74">&#34;</span> : <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Continuing</span><span style="color:#e6db74">&#34;</span>
  <span style="color:#66d9ef">break</span> <span style="color:#66d9ef">true</span> <span style="color:#66d9ef">if</span> e
  a
<span style="color:#66d9ef">end</span>
<span style="color:#75715e"># Continuing</span>
<span style="color:#75715e"># Breaking</span>
<span style="color:#75715e"># =&gt; true</span>

<span style="color:#75715e"># &#34;Breaking&#34; + no more output means short circuiting. Voila!</span>
</code></pre></div><p>In other words, Ruby gives us a version of <code>fold</code> that allows us to
short-circuit the looping. This isn't possible in all languages, however.
Consider this JavaScript:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fold</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">array</span>, <span style="color:#a6e22e">fn</span>, <span style="color:#a6e22e">initialAccumulator</span>) =&gt; {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">accumulator</span> <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">initialAccumulator</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;undefined&#34;</span> <span style="color:#f92672">?</span> [] <span style="color:#f92672">:</span> <span style="color:#a6e22e">initialAccumulator</span>;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">element</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">array</span>) {
    <span style="color:#a6e22e">accumulator</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">fn</span>(<span style="color:#a6e22e">accumulator</span>, <span style="color:#a6e22e">element</span>);
  }
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">accumulator</span>;
};

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">any</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">array</span>, <span style="color:#a6e22e">fn</span>) =&gt; {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fold</span>(
    <span style="color:#a6e22e">array</span>,
    (<span style="color:#a6e22e">truthFlag</span>, <span style="color:#a6e22e">element</span>) =&gt; {
      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">fn</span>(<span style="color:#a6e22e">element</span>)) {
        <span style="color:#66d9ef">break</span> <span style="color:#66d9ef">true</span>; <span style="color:#75715e">// This isn&#39;t valid syntax.
</span><span style="color:#75715e"></span>      } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">truthFlag</span>;
      }
    },
    <span style="color:#66d9ef">false</span>,
  );
};
</code></pre></div><p>In Ruby, putting <code>break</code> in a block is pretty powerful. It causes a return
from the function that <code>yield</code>ed to that block. In other words, it <em>reaches
outside of its own scope</em> and causes the function that called <em>it</em> to return.
What's more, <code>break</code> is an expression that can make that outer function
return the value you give it: <code>break true</code>, for example. If this seems subtle
and in the weeds, the takeaway is that Ruby lets you hit the eject button
from way down inside the scope of the thing<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> passed to <code>reduce</code>
during one particular iteration of that function, reach up to the <code>reduce</code>
itself, and make the whole <code>reduce</code> bail out.</p>
<p>That simply isn't possible in JavaScript as a <code>break</code> doesn't have the power
to cause an outer function to return. The JavaScript interpreter looks at the
<code>break</code> and thinks we must be talking about the anonymous function it's
inside of, the one that begins <code>(accumulator, element) =&gt;</code>. And it says,
&ldquo;What do you mean, <code>break</code>? I don't see any loop inside my scope!&rdquo; The
interpreter doesn't take any notice of the fact that the anonymous function
is called from inside a loop. That's a different scope, and as I said,
JavaScript doesn't let something inside the anonymous function pop its head
out of its own scope and then tinker with the control flow of the loop it's
situated inside of, namely the <code>fold</code> itself.</p>
<p>Think of it this way: imagine we wrote the function separately, like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// Assume `fold`, as defined above, is in scope.
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">anyHelper</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">fn</span> =&gt; {
  <span style="color:#75715e">// Return a function appropriate for passing to `fold`. We will need to curry
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// `anyHelper`, closing over `fn`, so that it matches the function signature
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// expected by `fold`&#39;s second argument.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">truthFlag</span>, <span style="color:#a6e22e">element</span>) =&gt; {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">fn</span>(<span style="color:#a6e22e">element</span>)) {
      <span style="color:#66d9ef">break</span> <span style="color:#66d9ef">true</span>; <span style="color:#75715e">// Invalid syntax. But imagine this worked for now.
</span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">truthFlag</span>;
    }
  };
};

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">any</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">array</span>, <span style="color:#a6e22e">fn</span>) =&gt; {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">curriedAnyHelper</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">anyHelper</span>(<span style="color:#a6e22e">fn</span>);

  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fold</span>(<span style="color:#a6e22e">array</span>, <span style="color:#a6e22e">curriedAnyHelper</span>, <span style="color:#66d9ef">false</span>);
};

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">any</span>([<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>], <span style="color:#a6e22e">x</span> =&gt; <span style="color:#a6e22e">x</span>));
</code></pre></div><p>But now somebody comes along and tries to call <code>anyHelper</code> directly.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">anyHelper</span>(<span style="color:#a6e22e">x</span> =&gt; <span style="color:#a6e22e">x</span>)(<span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>);
</code></pre></div><p>That's a weird thing to do, to be sure; it's a pretty useless function
outside of <code>fold</code>. But let's go with it. Now <code>break</code> makes absolutely no
sense. And we don't really want to have function syntax be valid or invalid
based on its enclosing scope.<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> There are several
other considerations weighing against this.<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></p>
<h2 id="there-are-ways-to-work-around-that-problem">There are ways to work around that problem.</h2>
<p>There are at least two ways to have the effect of breaking out of <code>fold</code> in
languages where that's not directly possible. The <code>itertools</code>
<a href="https://crates.io/crates/itertools">library</a> teaches one way, the
<code>fold_while</code> method. Then the Rust standard library provided a second
approach: <code>try_fold</code> (which actually led to <code>itertools</code>'s deprecating
<code>fold_while</code>, though I think <code>fold_while</code> is still the best approach in some
circumstances).</p>
<h3 id="fold-while-wraps-the-accumulator-in-a-continue-or-done-to-interact-with-looping"><code>fold_while</code> wraps the accumulator in a <code>Continue</code> or <code>Done</code> to interact with looping.</h3>
<p>So that we can stick with JavaScript, I will define <code>fold_while</code>, stolen from
Rust's <code>itertools</code> concept, in JS. The upshot is that we will wrap the
accumulator in <code>Continue</code> or <code>Done</code>. Before the loop each iterates each time,
it checks to see which wrapper the previous iteration returned. If it's a
<code>Done</code>, the loop breaks.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#75715e">// Our interface for `Continue` and `Done` will wrap a value that can be
</span><span style="color:#75715e"></span><span style="color:#75715e">// unwrapped with `intoInner`, and also report whether we should continue or
</span><span style="color:#75715e"></span><span style="color:#75715e">// not.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IFoldWhile</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> {
  <span style="color:#a6e22e">intoInner</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">T</span>;
  <span style="color:#a6e22e">shouldContinue</span><span style="color:#f92672">:</span> () <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">boolean</span>;
}

<span style="color:#75715e">// Implement the shared part of our functionality.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FoldWhileBaseContainer</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">Partial</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">IFoldWhile</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;&gt;</span> {
  <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>;

  <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
  }

  <span style="color:#a6e22e">intoInner() {</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>;
  }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FoldWhileContinue</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">FoldWhileBaseContainer</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
  <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">IFoldWhile</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> {
  <span style="color:#a6e22e">shouldContinue() {</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
  }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FoldWhileDone</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">FoldWhileBaseContainer</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
  <span style="color:#66d9ef">implements</span> <span style="color:#a6e22e">IFoldWhile</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> {
  <span style="color:#a6e22e">shouldContinue() {</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
  }
}

<span style="color:#75715e">// Convenience factory helper thingies
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Continue</span><span style="color:#f92672">:</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">IFoldWhile</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span>
  <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">FoldWhileContinue</span>(<span style="color:#a6e22e">value</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Done</span><span style="color:#f92672">:</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">IFoldWhile</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span>
  <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">FoldWhileDone</span>(<span style="color:#a6e22e">value</span>);

<span style="color:#75715e">// Here&#39;s the actual `fold` function we&#39;re defining. The preceding has been
</span><span style="color:#75715e"></span><span style="color:#75715e">// setup.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">foldWhile</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span>, <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>(
  <span style="color:#a6e22e">array</span>: <span style="color:#66d9ef">T</span>[],
  <span style="color:#a6e22e">fn</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">acc</span>: <span style="color:#66d9ef">U</span>, <span style="color:#a6e22e">el</span>: <span style="color:#66d9ef">T</span>) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">IFoldWhile</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>,
  <span style="color:#a6e22e">initialAccumulator</span>: <span style="color:#66d9ef">U</span>,
) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">accumulator</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Continue</span>(
    <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">initialAccumulator</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;undefined&#34;</span> <span style="color:#f92672">?</span> [] <span style="color:#f92672">:</span> <span style="color:#a6e22e">initialAccumulator</span>,
  );

  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">element</span> <span style="color:#a6e22e">of</span> <span style="color:#a6e22e">array</span>) {
    <span style="color:#75715e">// Are we supposed to `Continue`? If we get a `FoldWhileContinue`-wrapped
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// value from the previous iteration, we continue with the normal `fold`.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">accumulator</span>.<span style="color:#a6e22e">shouldContinue</span>()) {
      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">continueValue</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">accumulator</span>.<span style="color:#a6e22e">intoInner</span>() <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">U</span>;
      <span style="color:#a6e22e">accumulator</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">fn</span>(<span style="color:#a6e22e">continueValue</span>, <span style="color:#a6e22e">element</span>);

      <span style="color:#75715e">// Or are we supposed to be `Done`? This is the key to short-circuiting.
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// If we get a `FoldWhileDone`-wrapped value, we `break`.
</span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
      <span style="color:#66d9ef">break</span>;
    }
  }

  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">accumulator</span>;
};

<span style="color:#75715e">// Now we can define a short-circuiting `any` based on `foldWhile`.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">any</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">array</span>: <span style="color:#66d9ef">T</span>[], <span style="color:#a6e22e">fn</span><span style="color:#f92672">:</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">value</span>: <span style="color:#66d9ef">T</span>) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">boolean</span>) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">foldWhile</span>(
    <span style="color:#a6e22e">array</span>,
    (<span style="color:#a6e22e">truthFlag</span>, <span style="color:#a6e22e">element</span>) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> {
      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Running&#34;</span>);
      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fn</span>(<span style="color:#a6e22e">element</span>) <span style="color:#f92672">?</span> <span style="color:#a6e22e">Done</span>(<span style="color:#66d9ef">true</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">Continue</span>(<span style="color:#66d9ef">false</span>);
    },
    <span style="color:#66d9ef">false</span>,
  ).<span style="color:#a6e22e">intoInner</span>();
};

<span style="color:#a6e22e">any</span>([<span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>], <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">!</span><span style="color:#f92672">!</span><span style="color:#a6e22e">x</span>);
<span style="color:#75715e">// Running
</span><span style="color:#75715e"></span><span style="color:#75715e">// Running
</span><span style="color:#75715e"></span><span style="color:#75715e">// Running
</span><span style="color:#75715e"></span><span style="color:#75715e">// Running
</span><span style="color:#75715e"></span><span style="color:#75715e">// Running
</span><span style="color:#75715e"></span><span style="color:#75715e">// =&gt; true
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">any</span>([<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>], <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">!</span><span style="color:#f92672">!</span><span style="color:#a6e22e">x</span>);
<span style="color:#75715e">// Running
</span><span style="color:#75715e"></span><span style="color:#75715e">// =&gt; true
</span></code></pre></div><p>The function passed to <code>fold</code> is no longer trying to alter control flow
<em>directly</em>. Instead, it is passing a message up to <code>foldWhile</code>, and
<code>foldWhile</code> is the thing actually calling <code>break</code>. It's no longer something
like a <code>goto</code>; it's now a message being passed.</p>
<p>We can do the same kind of thing for our &ldquo;game&rdquo; from the <a href="https://ethankent.dev/posts/i_fold#fold-is-useful-when-we-must-iterate-with-a-flag-or-intermediate-result">previous
post</a>,
in which you must collect one <code>tinyBoomer</code> or two <code>megaBoomers</code> to win, a
<code>nothing</code> does nothing and a <code>whammy</code> makes you lose, assuming you haven’t
yet won.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tinyBoomer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Symbol</span>(<span style="color:#e6db74">&#34;tinyBoomer&#34;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">megaBoomer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Symbol</span>(<span style="color:#e6db74">&#34;megaBoomer&#34;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">nothing</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Symbol</span>(<span style="color:#e6db74">&#34;nothing&#34;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">whammy</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Symbol</span>(<span style="color:#e6db74">&#34;whammy&#34;</span>);

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">isWinningGame</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">gameTape</span> =&gt; {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">foldWhile</span>(
    <span style="color:#a6e22e">gameTape</span>,
    (<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">event</span>) =&gt; {
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(<span style="color:#a6e22e">status</span>.<span style="color:#a6e22e">hasWon</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">status</span>.<span style="color:#a6e22e">hasLost</span>)) {
        <span style="color:#66d9ef">switch</span> (<span style="color:#a6e22e">event</span>) {
          <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">whammy</span><span style="color:#f92672">:</span>
            <span style="color:#a6e22e">status</span>.<span style="color:#a6e22e">hasLost</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
            <span style="color:#66d9ef">break</span>;
          <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">megaBoomer</span><span style="color:#f92672">:</span>
            <span style="color:#a6e22e">status</span>.<span style="color:#a6e22e">hasWon</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
            <span style="color:#66d9ef">break</span>;
          <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">tinyBoomer</span><span style="color:#f92672">:</span>
            <span style="color:#a6e22e">status</span>.<span style="color:#a6e22e">tinyBoomerCount</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">status</span>.<span style="color:#a6e22e">tinyBoomerCount</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span>) <span style="color:#a6e22e">status</span>.<span style="color:#a6e22e">hasWon</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
        }
      }
      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">gameOver</span>(<span style="color:#a6e22e">status</span>) <span style="color:#f92672">?</span> <span style="color:#a6e22e">Done</span>(<span style="color:#a6e22e">status</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">Continue</span>(<span style="color:#a6e22e">status</span>);
    },
    {
      <span style="color:#a6e22e">hasWon</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span>,
      <span style="color:#a6e22e">hasLost</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span>,
      <span style="color:#a6e22e">tinyBoomerCount</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>,
    },
  ).<span style="color:#a6e22e">intoInner</span>().<span style="color:#a6e22e">hasWon</span>;
};

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">winner</span> <span style="color:#f92672">=</span> [<span style="color:#a6e22e">tinyBoomer</span>, <span style="color:#a6e22e">nothing</span>, <span style="color:#a6e22e">nothing</span>, <span style="color:#a6e22e">tinyBoomer</span>, <span style="color:#a6e22e">whammy</span>];
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">loser</span> <span style="color:#f92672">=</span> [<span style="color:#a6e22e">tinyBoomer</span>, <span style="color:#a6e22e">nothing</span>, <span style="color:#a6e22e">whammy</span>, <span style="color:#a6e22e">tinyBoomer</span>, <span style="color:#a6e22e">megaBoomer</span>];

<span style="color:#a6e22e">isWinningGame</span>(<span style="color:#a6e22e">winner</span>);
<span style="color:#a6e22e">isWinningGame</span>(<span style="color:#a6e22e">loser</span>);

<span style="color:#75715e">// =&gt; true
</span><span style="color:#75715e"></span><span style="color:#75715e">// =&gt; false
</span></code></pre></div><p>This kind of approach is probably the best we can do in JavaScript. But
Rust's standard library now has a built-in method for breaking out of <code>fold</code>.</p>
<h3 id="rusts-try-fold-gives-us-a-way-to-break-folding-using-the-standard-library">Rust's <code>try_fold</code> gives us a way to break folding using the standard library.</h3>
<p>Rust's <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_fold">standard
library</a>
now exposes a <code>try_fold</code> method on iterators. It automatically breaks when
the closure passed to it returns a <code>None</code> value. The only problem that raises
is that <code>None</code> can't wrap a return value like the <code>itertools</code> library's
<code>Done</code> variant, and so we can't do the equivalent of Ruby's <code>break foo</code>, in
which the syntax we use to cause the looping to quit is capable of returning
a value. That's why I think <code>itertools</code> shouldn't deprecate <code>fold_while</code>.</p>
<p>Anyway, we <em>can</em> use <code>try_fold</code> to define <code>any</code>, as shown below, though it's
a kind of ugly, awkward solution. As mentioned, <code>try_fold</code> keeps looping as
long as the accumulator is a <code>Some</code> type. It breaks the first time it gets a
<code>None</code>. So we could probably skip the <code>true</code>s and <code>false</code>s altogether, and
the fact that <code>None</code> means <code>true</code> is confusing. We really are abusing the
method at this point.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// We would actually make this generic over any iterable, but for simplicity&#39;s
</span><span style="color:#75715e"></span><span style="color:#75715e">// sake...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">any</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(arr: <span style="color:#66d9ef">&amp;</span>Vec<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>, func: <span style="color:#a6e22e">fn</span>(<span style="color:#f92672">&amp;</span>T) -&gt; <span style="color:#66d9ef">bool</span>) -&gt; <span style="color:#66d9ef">bool</span> {
    arr.iter().try_fold(<span style="color:#66d9ef">false</span>, <span style="color:#f92672">|</span>truth_flag, element<span style="color:#f92672">|</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Running&#34;</span>);
        <span style="color:#66d9ef">if</span> func(element) {
            <span style="color:#75715e">// We need `None` to break iteration, but it actually represents a
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// `true` result, which is confusing.
</span><span style="color:#75715e"></span>            None
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#75715e">// We don&#39;t really need the accumulator at all.
</span><span style="color:#75715e"></span>            Some(truth_flag)
        }
    }).is_none()
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> not_short_circuitable <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>];
    <span style="color:#66d9ef">let</span> short_circuitable <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>];

    assert<span style="color:#f92672">!</span>(any(<span style="color:#f92672">&amp;</span>not_short_circuitable, <span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> <span style="color:#f92672">*</span>x));
    assert<span style="color:#f92672">!</span>(any(<span style="color:#f92672">&amp;</span>short_circuitable, <span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> <span style="color:#f92672">*</span>x));
}
</code></pre></div><h2 id="this-any-stuff-was-all-to-prove-a-point-dont--actually--define-any-with-fold">This <code>any</code> stuff was all to prove a point; don't <em>actually</em> define <code>any</code> with <code>fold</code>.</h2>
<p>The best way to define <code>any</code> in a language that uses iteration is something
like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">any</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">array</span>, <span style="color:#a6e22e">fn</span>) =&gt; {
  <span style="color:#66d9ef">for</span> (<span style="color:#a6e22e">element</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">array</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">fn</span>(<span style="color:#a6e22e">element</span>)) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
};
</code></pre></div><p>The best way to define <code>any</code> in a language that uses recursion is something
like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">any</span> <span style="color:#f92672">=</span> ([<span style="color:#a6e22e">head</span>, ...<span style="color:#a6e22e">tail</span>], <span style="color:#a6e22e">fn</span>) =&gt;
  <span style="color:#a6e22e">head</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">false</span> <span style="color:#f92672">:</span> <span style="color:#a6e22e">fn</span>(<span style="color:#a6e22e">head</span>) <span style="color:#f92672">||</span> <span style="color:#a6e22e">any</span>(<span style="color:#a6e22e">tail</span>, <span style="color:#a6e22e">fn</span>);
</code></pre></div><p>❧ ❧ ❧</p>
<p>So what was the point of all that? Well, it took me awhile to work out why
you couldn't use <code>break</code> in Rust's <code>fold</code> method and JavaScript's <code>reduce</code>
method. It helps me to consolidate my understanding of things to explain them
to others, as I have tried to do here.</p>
<p>Also, I do reach for <code>fold</code> a lot, but the inability to <code>break</code> tends
to be a sign that a different abstraction might be preferable.</p>
<p>That said, I think something like my implementation of <code>isWinningGame</code> is the
best way to solve that kind of problem, and there <code>break</code>ing is an important
part of the implementation. I would simply extract a struct or class to
represent the complex &ldquo;flag&rdquo; used as the accumulator. People can certainly
disagree with that approach, but I think there's a lot of value in keeping
the instance of the flag integral to the looping construct outside of which
the flag makes no sense.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>For <code>any</code> that means once we encounter the first value that causes the anonymous function to return a truthy value, and for <code>all</code> that means the first value that causes the anonymous function to return a falsey value. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>I use <em>thing</em> advisedy: it's important that it's a block rather than a function in Ruby. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>That's different than simply introducing a bug based on something going on in the enclosing scope. We can easily do that with a function that closes over an undefined variable or a variable of the wrong type. But that's a runtime issue. Again, it's not that the <em>syntax</em> became invalid based on a runtime binding. <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>First, how far up the call stack should <code>break</code> be allowed to traverse? Sure, we might say &ldquo;only one level,&rdquo; but now we can't extract a sub-helper out of the function passed to <code>fold</code>. Second, we are fundamentally messing with a <code>goto</code>-like construct which is Something to Worry About. (I am aware of JavaScript <code>break</code> statements with <code>label</code>s, and see how that could help address some of these issues I'm raising. The main reason for not allowing <code>break</code> is, I think, stated in the main text.) <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>


		
	</div>

	<div class="pagination">
		<a href="/posts/i_fold/" class="left arrow">&#8592;</a>
		<a href="/posts/thats_my_bag/" class="right arrow">&#8594;</a>

		<a href="#" class="top">Top</a>
	</div>
</main>


        		<footer>
			<span>
			&copy; <time datetime="2020-01-28 12:46:25.407817 -0600 CST m=&#43;0.223243347">2020</time> Ethan Kent. Made with <a href='https://gohugo.io'>Hugo</a> using the <a href='https://github.com/EmielH/tale-hugo/'>Tale</a> theme.
			</span>
		</footer>

    </body>
</html>
