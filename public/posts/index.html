<!DOCTYPE html>
<html lang="en-us">
    <head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<title>Posts &middot; Ethan Kent&#39;s Blog</title>

		
  		<link rel="stylesheet" href="/css/style.css">
		<link rel="stylesheet" href="/css/fonts.css">
		
		<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
		<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

		
		<link href="/posts/index.xml" rel="alternate" type="application/rss+xml" title="Ethan Kent&#39;s Blog" />
	</head>

    <body>
        		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					<h2 class="nav-title">Ethan Kent&#39;s Blog</h2>
				</a>
				<ul>
    
    
</ul>
			</div>
		</nav>

        

<main>
	<div class="catalogue">
		
			<a href="https://ethankent.dev/posts/implementing_a_bag/" class="catalogue-item">
    <div>
        <time datetime="2020-01-03 11:39:14 -0800 -0800" class="catalogue-time">January 3, 2020</time>
        <h1 class="catalogue-title">Implementing a bag</h1>
        <div class="catalogue-line"></div>

        <p>
            In my previous post, I talked about a bag data structure, which is like a set that allows repeated occurrences of the same value.
In this post I will discuss my naïve implementation that has the goal of O(1) best case insertion, search, and deletion. You can follow along by viewing the code at https://www.github.com/ethan826/bag.
In the next post I'll discuss improvements to consider, mostly around improving the hash function and considering load factor.
        </p>
    </div>
</a>

		
			<a href="https://ethankent.dev/posts/thats_my_bag/" class="catalogue-item">
    <div>
        <time datetime="2020-01-01 12:13:12 -0600 CST" class="catalogue-time">January 1, 2020</time>
        <h1 class="catalogue-title">That&#39;s my bag, baby</h1>
        <div class="catalogue-line"></div>

        <p>
            (This is part of a series of articles. The next one is here.)
When we want a collection with elements that may repeat, we generally reach for an array, list, vector, etc. When we want a collection with elements that don't or whose repeats we don't care about, we generally reach for a set.
Efficient set implementations often don't track insertion order. For hashsets, that's because they hash their input and organize based on that hashed value.
        </p>
    </div>
</a>

		
			<a href="https://ethankent.dev/posts/breaking_fold/" class="catalogue-item">
    <div>
        <time datetime="2019-12-15 15:58:10 -0600 CST" class="catalogue-time">December 15, 2019</time>
        <h1 class="catalogue-title">Breaking out of the fold</h1>
        <div class="catalogue-line"></div>

        <p>
            This article addresses an issue alluded to in my previous one. Namely, we sometimes want to break out of the iteration within fold, but it is not easy to do that in many languages.
fold has a problem with short-circuiting. In defining any and all by using fold, as we did in the previous article, we did not short-circuit. But we'd get a better constant factor for our time complexity if we can break from those methods once we know the final outcome.
        </p>
    </div>
</a>

		
			<a href="https://ethankent.dev/posts/i_fold/" class="catalogue-item">
    <div>
        <time datetime="2019-12-08 14:15:00 -0600 CST" class="catalogue-time">December 8, 2019</time>
        <h1 class="catalogue-title">I fold!</h1>
        <div class="catalogue-line"></div>

        <p>
            This article is a love letter to fold, a.k.a. reduce, a.k.a. inject.1
I love fold for three reasons. First, it is useful in a wide variety of programming contexts. Second, it is a ladder between different levels of abstraction: it is simple to define, but allows operating on collections more abstractly. Third, it can have the same API but be defined based on looping or recursion, and so can help you solve similar problems in similar ways despite coding in different paradigms.
        </p>
    </div>
</a>

		
			<a href="https://ethankent.dev/posts/priors/" class="catalogue-item">
    <div>
        <time datetime="2019-12-02 12:50:00 -0600 CST" class="catalogue-time">December 2, 2019</time>
        <h1 class="catalogue-title">Priors</h1>
        <div class="catalogue-line"></div>

        <p>
            There's a lyric in a They Might Be Giants song:1
 Now you're the only one here,Who can tell me if it's true:That you love me,And I love me.
 The lyric is effective because it uses our expectations of rhyme scheme, parallelism, and reciprocity to have us all but certain that the final line of the verse will end with you. And the surprise serves a purpose: it uses the flouting of our expectations as a way of making us feel the potency of the narrator's self-centeredness.
        </p>
    </div>
</a>

		
			<a href="https://ethankent.dev/posts/types_are_for_people/" class="catalogue-item">
    <div>
        <time datetime="2019-11-14 09:00:00 -0600 CST" class="catalogue-time">November 14, 2019</time>
        <h1 class="catalogue-title">Types Are for People, not Computers</h1>
        <div class="catalogue-line"></div>

        <p>
            Types—in the static-typing sense—are useful because they help people, not computers. Oh sure, we use them, in part, to subdue the compiler or meet some need peculiarly arising from our computer. But types are valuable because they are a way of communicating.
Type systems are a way of communicating. Type systems are a way of announcing what you understand, expect, or intend. Good type systems let you do so at the level of abstraction you choose.
        </p>
    </div>
</a>

		
			<a href="https://ethankent.dev/posts/mutation_scopes/" class="catalogue-item">
    <div>
        <time datetime="2019-11-05 15:05:29 -0600 CST" class="catalogue-time">November 5, 2019</time>
        <h1 class="catalogue-title">Limiting the scope of mutation</h1>
        <div class="catalogue-line"></div>

        <p>
            Functional programming teaches us about the dangers of mutability. But some object-oriented code mutates variables freely, in different scopes, along different code paths, and in many places.
To maintain our ability to reason about code, we can learn from functional programming and treat mutation as a risk to be managed. Even if we stop short of mandatory immutability and using constructs like monads, we can still manage mutations and recognize them as a source of bugs and confusion.
        </p>
    </div>
</a>

		
	</div>
	
	<div class="pagination">
		
		
	
		<span>1</span>
	</div>
</main>


        		<footer>
			<span>
			&copy; <time datetime="2020-01-05 11:02:56.984783 -0600 CST m=&#43;0.414202358">2020</time> Ethan Kent. Made with <a href='https://gohugo.io'>Hugo</a> using the <a href='https://github.com/EmielH/tale-hugo/'>Tale</a> theme.
			</span>
		</footer>

    </body>
</html>
