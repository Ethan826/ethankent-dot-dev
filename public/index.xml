<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ethan Kent&#39;s Blog</title>
    <link>https://ethankent.dev/</link>
    <description>Recent content on Ethan Kent&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 03 Jan 2020 07:23:09 -0800</lastBuildDate>
    
	<atom:link href="https://ethankent.dev/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Implementing a bag</title>
      <link>https://ethankent.dev/posts/implementing_a_bag/</link>
      <pubDate>Fri, 03 Jan 2020 07:23:09 -0800</pubDate>
      
      <guid>https://ethankent.dev/posts/implementing_a_bag/</guid>
      <description>In my previous post, I talked about a bag data structure, which is like a set that allows repeated occurrences of the same value.
In this post I will discuss my naïve implementation that has the goal of O(1) best case insertion, search, and deletion. You can follow along by viewing the code at https://www.github.com/ethan826/bag.
In the next post I&#39;ll discuss improvements to consider, mostly around improving the hash function and considering load factor.</description>
    </item>
    
    <item>
      <title>That&#39;s my bag, baby</title>
      <link>https://ethankent.dev/posts/thats_my_bag/</link>
      <pubDate>Wed, 01 Jan 2020 12:13:12 -0600</pubDate>
      
      <guid>https://ethankent.dev/posts/thats_my_bag/</guid>
      <description>When we want a collection with elements that may repeat, we generally reach for an array, list, vector, etc. When we want a collection with elements that don&#39;t or whose repeats we don&#39;t care about, we generally reach for a set.
Efficient set implementations often don&#39;t track insertion order. For hashsets, that&#39;s because they hash their input and organize based on that hashed value. For binary tree sets, it&#39;s because inputs are sorted in a binary tree.</description>
    </item>
    
    <item>
      <title>Breaking out of the fold</title>
      <link>https://ethankent.dev/posts/breaking_fold/</link>
      <pubDate>Sun, 15 Dec 2019 15:58:10 -0600</pubDate>
      
      <guid>https://ethankent.dev/posts/breaking_fold/</guid>
      <description>This article addresses an issue alluded to in my previous one. Namely, we sometimes want to break out of the iteration within fold, but it is not easy to do that in many languages.
fold has a problem with short-circuiting. In defining any and all by using fold, as we did in the previous article, we did not short-circuit. But we&#39;d get a better constant factor for our time complexity if we can break from those methods once we know the final outcome.</description>
    </item>
    
    <item>
      <title>I fold!</title>
      <link>https://ethankent.dev/posts/i_fold/</link>
      <pubDate>Sun, 08 Dec 2019 14:15:00 -0600</pubDate>
      
      <guid>https://ethankent.dev/posts/i_fold/</guid>
      <description>This article is a love letter to fold, a.k.a. reduce, a.k.a. inject.1
I love fold for three reasons. First, it is useful in a wide variety of programming contexts. Second, it is a ladder between different levels of abstraction: it is simple to define, but allows operating on collections more abstractly. Third, it can have the same API but be defined based on looping or recursion, and so can help you solve similar problems in similar ways despite coding in different paradigms.</description>
    </item>
    
    <item>
      <title>Priors</title>
      <link>https://ethankent.dev/posts/priors/</link>
      <pubDate>Mon, 02 Dec 2019 12:50:00 -0600</pubDate>
      
      <guid>https://ethankent.dev/posts/priors/</guid>
      <description>There&#39;s a lyric in a They Might Be Giants song:1
 Now you&#39;re the only one here,Who can tell me if it&#39;s true:That you love me,And I love me.
 The lyric is effective because it uses our expectations of rhyme scheme, parallelism, and reciprocity to have us all but certain that the final line of the verse will end with you. And the surprise serves a purpose: it uses the flouting of our expectations as a way of making us feel the potency of the narrator&#39;s self-centeredness.</description>
    </item>
    
    <item>
      <title>Types Are for People, not Computers</title>
      <link>https://ethankent.dev/posts/types_are_for_people/</link>
      <pubDate>Thu, 14 Nov 2019 09:00:00 -0600</pubDate>
      
      <guid>https://ethankent.dev/posts/types_are_for_people/</guid>
      <description>Types—in the static-typing sense—are useful because they help people, not computers. Oh sure, we use them, in part, to subdue the compiler or meet some need peculiarly arising from our computer. But types are valuable because they are a way of communicating.
Type systems are a way of communicating. Type systems are a way of announcing what you understand, expect, or intend. Good type systems let you do so at the level of abstraction you choose.</description>
    </item>
    
    <item>
      <title>Limiting the scope of mutation</title>
      <link>https://ethankent.dev/posts/mutation_scopes/</link>
      <pubDate>Tue, 05 Nov 2019 15:05:29 -0600</pubDate>
      
      <guid>https://ethankent.dev/posts/mutation_scopes/</guid>
      <description>Functional programming teaches us about the dangers of mutability. But some object-oriented code mutates variables freely, in different scopes, along different code paths, and in many places.
To maintain our ability to reason about code, we can learn from functional programming and treat mutation as a risk to be managed. Even if we stop short of mandatory immutability and using constructs like monads, we can still manage mutations and recognize them as a source of bugs and confusion.</description>
    </item>
    
  </channel>
</rss>